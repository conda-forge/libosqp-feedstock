From b92e09deaeb0d5a9bb2d767bcb65809fecf83961 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20P=C3=B6lsterl?= <sebp@k-d-w.org>
Date: Wed, 23 Apr 2025 09:08:08 +0200
Subject: [PATCH 4/4] Export additional functions part of the API

---
 algebra/_common/kkt.h               |   8 +--
 include/private/algebra_matrix.h    |  48 ++++++-------
 include/private/algebra_vector.h    | 104 ++++++++++++++--------------
 include/private/lin_alg.h           |  14 ++--
 include/public/osqp_api_functions.h |  22 +++---
 5 files changed, 98 insertions(+), 98 deletions(-)

diff --git a/algebra/_common/kkt.h b/algebra/_common/kkt.h
index e59feb19..1406605f 100644
--- a/algebra/_common/kkt.h
+++ b/algebra/_common/kkt.h
@@ -35,7 +35,7 @@ extern "C" {
  *KKT
  * @return            return status flag
  */
- OSQPCscMatrix* form_KKT(OSQPCscMatrix* P,
+OSQP_API OSQPCscMatrix* form_KKT(OSQPCscMatrix* P,
                          OSQPCscMatrix* A,
                          OSQPInt        format,
                          OSQPFloat      param1,
@@ -60,7 +60,7 @@ extern "C" {
  * @param param1    Parameter added to the diagonal elements of P
  * @param format    0 for CSC, 1 for CSR
  */
- void update_KKT_P(OSQPCscMatrix* KKT,
+OSQP_API void update_KKT_P(OSQPCscMatrix* KKT,
                    OSQPCscMatrix* P,
                    const OSQPInt* Px_new_idx,
                    OSQPInt        P_new_n,
@@ -78,7 +78,7 @@ extern "C" {
  * @param A_new_n   number of elements of A to be updated
  * @param AtoKKT    Vector of pointers from A->x to KKT->x
  */
- void update_KKT_A(OSQPCscMatrix* KKT,
+OSQP_API void update_KKT_A(OSQPCscMatrix* KKT,
                    OSQPCscMatrix* A,
                    const OSQPInt* Ax_new_idx,
                    OSQPInt        A_new_n,
@@ -94,7 +94,7 @@ extern "C" {
  * @param param2toKKT   index where param2 enters in the KKT matrix
  * @param m             number of constraints
  */
-void update_KKT_param2(OSQPCscMatrix* KKT,
+OSQP_API void update_KKT_param2(OSQPCscMatrix* KKT,
                        OSQPFloat*     param2,
                        OSQPFloat      param2_sc,
                        OSQPInt*       param2toKKT,
diff --git a/include/private/algebra_matrix.h b/include/private/algebra_matrix.h
index 336a9d82..2074e2c8 100644
--- a/include/private/algebra_matrix.h
+++ b/include/private/algebra_matrix.h
@@ -23,7 +23,7 @@ typedef struct OSQPMatrix_ OSQPMatrix;
 
 /*  logical functions ------------------------------------------------------*/
 
-OSQPInt OSQPMatrix_is_eq(const OSQPMatrix* A,
+OSQP_API OSQPInt OSQPMatrix_is_eq(const OSQPMatrix* A,
                          const OSQPMatrix* B,
                                OSQPFloat   tol);
 
@@ -31,20 +31,20 @@ OSQPInt OSQPMatrix_is_eq(const OSQPMatrix* A,
 
 
 //Make a copy from a csc matrix.  Returns OSQP_NULL on failure
-OSQPMatrix* OSQPMatrix_new_from_csc(const OSQPCscMatrix* A,
+OSQP_API OSQPMatrix* OSQPMatrix_new_from_csc(const OSQPCscMatrix* A,
                                           OSQPInt        is_triu);
 
 /* Return a copy of the matrix in CSC format */
-OSQPCscMatrix* OSQPMatrix_get_csc(const OSQPMatrix* M);
+OSQP_API OSQPCscMatrix* OSQPMatrix_get_csc(const OSQPMatrix* M);
 
 /* Return a copy of a matrix as output (Uses MALLOC) */
-OSQPMatrix* OSQPMatrix_copy_new(const OSQPMatrix* A);
+OSQP_API OSQPMatrix* OSQPMatrix_copy_new(const OSQPMatrix* A);
 
 // Convert an upper triangular matrix into a fully populated matrix
-OSQPMatrix* OSQPMatrix_triu_to_symm(const OSQPMatrix* A);
+OSQP_API OSQPMatrix* OSQPMatrix_triu_to_symm(const OSQPMatrix* A);
 
 // Vertically stack two matrices
-OSQPMatrix* OSQPMatrix_vstack(const OSQPMatrix* A, const OSQPMatrix* B);
+OSQP_API OSQPMatrix* OSQPMatrix_vstack(const OSQPMatrix* A, const OSQPMatrix* B);
 
 #endif //OSQP_EMBEDDED_MODE
 
@@ -57,61 +57,61 @@ OSQPMatrix* OSQPMatrix_vstack(const OSQPMatrix* A, const OSQPMatrix* B);
 *   with user defined linear solvers and the user API
 */
 
-void OSQPMatrix_update_values(OSQPMatrix*      M,
+OSQP_API void OSQPMatrix_update_values(OSQPMatrix*      M,
                               const OSQPFloat* Mx_new,
                               const OSQPInt*   Mx_new_idx,
                               OSQPInt          M_new_n);
 
 /* returns the row dimension */
-OSQPInt    OSQPMatrix_get_m(const OSQPMatrix* M);
+OSQP_API OSQPInt    OSQPMatrix_get_m(const OSQPMatrix* M);
 
 /* returns the columns dimension */
-OSQPInt    OSQPMatrix_get_n(const OSQPMatrix* M);
+OSQP_API OSQPInt    OSQPMatrix_get_n(const OSQPMatrix* M);
 
 /* returns a pointer to the array of data values */
-OSQPFloat* OSQPMatrix_get_x(const OSQPMatrix* M);
+OSQP_API OSQPFloat* OSQPMatrix_get_x(const OSQPMatrix* M);
 
 /* returns a pointer to the array of row indices */
-OSQPInt*   OSQPMatrix_get_i(const OSQPMatrix* M);
+OSQP_API OSQPInt*   OSQPMatrix_get_i(const OSQPMatrix* M);
 
 /* returns a pointer to the array of col indices (csc format).  Should be n+1 long */
-OSQPInt*   OSQPMatrix_get_p(const OSQPMatrix* M);
+OSQP_API OSQPInt*   OSQPMatrix_get_p(const OSQPMatrix* M);
 
 /* returns the number of nonzeros (length of x and i arrays) */
-OSQPInt    OSQPMatrix_get_nz(const OSQPMatrix* M);
+OSQP_API OSQPInt    OSQPMatrix_get_nz(const OSQPMatrix* M);
 
 /* math functions ----------------------------------------------------------*/
 
 //A = sc*A
-void OSQPMatrix_mult_scalar(OSQPMatrix* A,
+OSQP_API void OSQPMatrix_mult_scalar(OSQPMatrix* A,
                             OSQPFloat     sc);
 
 //A = L*A, with diagonal entries of L specified
-void OSQPMatrix_lmult_diag(OSQPMatrix*        A,
+OSQP_API void OSQPMatrix_lmult_diag(OSQPMatrix*        A,
                            const OSQPVectorf* L);
 
 //A = A*R, with diagonal entries of R specified
-void OSQPMatrix_rmult_diag(OSQPMatrix*        A,
+OSQP_API void OSQPMatrix_rmult_diag(OSQPMatrix*        A,
                            const OSQPVectorf* R);
 
 // d = diag(At*diag(D)*A)
-void OSQPMatrix_AtDA_extract_diag(const OSQPMatrix*  A,
+OSQP_API void OSQPMatrix_AtDA_extract_diag(const OSQPMatrix*  A,
                                   const OSQPVectorf* D,
                                         OSQPVectorf* d);
 
 // Extract the main diagonal of A into d
-void OSQPMatrix_extract_diag(const OSQPMatrix*  A,
+OSQP_API void OSQPMatrix_extract_diag(const OSQPMatrix*  A,
                                    OSQPVectorf* d);
 
 //y = alpha*A*x + beta*y
-void OSQPMatrix_Axpy(const OSQPMatrix*  A,
+OSQP_API void OSQPMatrix_Axpy(const OSQPMatrix*  A,
                      const OSQPVectorf* x,
                      OSQPVectorf*       y,
                      OSQPFloat          alpha,
                      OSQPFloat          beta);
 
 //y = alpha*A^T*x + beta*y
-void OSQPMatrix_Atxpy(const OSQPMatrix*  A,
+OSQP_API void OSQPMatrix_Atxpy(const OSQPMatrix*  A,
                       const OSQPVectorf* x,
                       OSQPVectorf*       y,
                       OSQPFloat          alpha,
@@ -122,19 +122,19 @@ void OSQPMatrix_Atxpy(const OSQPMatrix*  A,
 
 #if OSQP_EMBEDDED_MODE != 1
 
-void OSQPMatrix_col_norm_inf(const OSQPMatrix*  M,
+OSQP_API void OSQPMatrix_col_norm_inf(const OSQPMatrix*  M,
                                    OSQPVectorf* E);
 
-void OSQPMatrix_row_norm_inf(const OSQPMatrix*  M,
+                                   OSQP_API void OSQPMatrix_row_norm_inf(const OSQPMatrix*  M,
                                    OSQPVectorf* E);
 
 #endif /* if OSQP_EMBEDDED_MODE != 1 */
 
 #ifndef OSQP_EMBEDDED_MODE
 
-void OSQPMatrix_free(OSQPMatrix* M);
+OSQP_API void OSQPMatrix_free(OSQPMatrix* M);
 
-OSQPMatrix* OSQPMatrix_submatrix_byrows(const OSQPMatrix*  A,
+OSQP_API OSQPMatrix* OSQPMatrix_submatrix_byrows(const OSQPMatrix*  A,
                                         const OSQPVectori* rows);
 
 #endif /* ifndef OSQP_EMBEDDED_MODE */
diff --git a/include/private/algebra_vector.h b/include/private/algebra_vector.h
index 4759d73b..08aafe52 100644
--- a/include/private/algebra_vector.h
+++ b/include/private/algebra_vector.h
@@ -25,37 +25,37 @@ typedef struct OSQPVectorf_ OSQPVectorf;
 
 # ifndef OSQP_EMBEDDED_MODE
 
-OSQPInt OSQPVectorf_is_eq(const OSQPVectorf* A,
+OSQP_API OSQPInt OSQPVectorf_is_eq(const OSQPVectorf* A,
                           const OSQPVectorf* B,
                           OSQPFloat          tol);
 
 /* malloc/calloc for floats and ints (USES MALLOC/CALLOC) */
-OSQPVectorf* OSQPVectorf_malloc(OSQPInt length);
-OSQPVectorf* OSQPVectorf_calloc(OSQPInt length);
-OSQPVectori* OSQPVectori_malloc(OSQPInt length);
-OSQPVectori* OSQPVectori_calloc(OSQPInt length);
+OSQP_API OSQPVectorf* OSQPVectorf_malloc(OSQPInt length);
+OSQP_API OSQPVectorf* OSQPVectorf_calloc(OSQPInt length);
+OSQP_API OSQPVectori* OSQPVectori_malloc(OSQPInt length);
+OSQP_API OSQPVectori* OSQPVectori_calloc(OSQPInt length);
 
 /* Return a float vector using a raw array as input (Uses MALLOC) */
-OSQPVectorf* OSQPVectorf_new(const OSQPFloat* a,
+OSQP_API OSQPVectorf* OSQPVectorf_new(const OSQPFloat* a,
                              OSQPInt          length);
 
 /* Return an int vector using a raw array as input (Uses MALLOC) */
-OSQPVectori* OSQPVectori_new(const OSQPInt* a,
+OSQP_API OSQPVectori* OSQPVectori_new(const OSQPInt* a,
                              OSQPInt        length);
 
 /* Return a copy of a float vector a as output (Uses MALLOC) */
-OSQPVectorf* OSQPVectorf_copy_new(const OSQPVectorf* a);
+OSQP_API OSQPVectorf* OSQPVectorf_copy_new(const OSQPVectorf* a);
 
 /* Free a float vector */
-void OSQPVectorf_free(OSQPVectorf* a);
+OSQP_API void OSQPVectorf_free(OSQPVectorf* a);
 
 /* Free an int vector */
-void OSQPVectori_free(OSQPVectori* a);
+OSQP_API void OSQPVectori_free(OSQPVectori* a);
 
 /*
  * Assign the data from array b to vector A starting at the index given by start.
  */
-void OSQPVectorf_subvector_assign(OSQPVectorf* A,
+OSQP_API void OSQPVectorf_subvector_assign(OSQPVectorf* A,
                                   OSQPFloat*   b,
                                   OSQPInt      start,
                                   OSQPInt      length,
@@ -64,70 +64,70 @@ void OSQPVectorf_subvector_assign(OSQPVectorf* A,
 /*
  * Assign a scalar to vector A starting at the index given by start.
  */
-void OSQPVectorf_subvector_assign_scalar(OSQPVectorf* A,
+OSQP_API void OSQPVectorf_subvector_assign_scalar(OSQPVectorf* A,
                                   OSQPFloat    sc,
                                   OSQPInt      start,
                                   OSQPInt      length);
 
-OSQPVectorf* OSQPVectorf_subvector_byrows(const OSQPVectorf* A,
+OSQP_API OSQPVectorf* OSQPVectorf_subvector_byrows(const OSQPVectorf* A,
                                           const OSQPVectori* rows);
 
-OSQPVectorf* OSQPVectorf_concat(const OSQPVectorf* A,
+OSQP_API OSQPVectorf* OSQPVectorf_concat(const OSQPVectorf* A,
                                 const OSQPVectorf* B);
 
 /* Create subview of a larger vector.  Internal data should not be freed.
  * Behavior is otherwise identical to OSQPVectorf (Uses MALLOC)
  */
-OSQPVectorf* OSQPVectorf_view(const OSQPVectorf* a,
+OSQP_API OSQPVectorf* OSQPVectorf_view(const OSQPVectorf* a,
                               OSQPInt            head,
                               OSQPInt            length);
 
 /* Points existing subview somewhere else.  (Does not use MALLOC)
  * TODO: Get rid of this function
  */
-void OSQPVectorf_view_update(OSQPVectorf* a, const OSQPVectorf* b, OSQPInt head, OSQPInt length);
+OSQP_API void OSQPVectorf_view_update(OSQPVectorf* a, const OSQPVectorf* b, OSQPInt head, OSQPInt length);
 
 /* Free a view of a float vector */
-void OSQPVectorf_view_free(OSQPVectorf* a);
+OSQP_API void OSQPVectorf_view_free(OSQPVectorf* a);
 
 # endif /* ifndef OSQP_EMBEDDED_MODE */
 
 
 /* Length of the vector (floats) */
-OSQPInt OSQPVectorf_length(const OSQPVectorf* a);
+OSQP_API OSQPInt OSQPVectorf_length(const OSQPVectorf* a);
 
 /* Length of the vector (ints) */
-OSQPInt OSQPVectori_length(const OSQPVectori* a);
+OSQP_API OSQPInt OSQPVectori_length(const OSQPVectori* a);
 
 /* Pointer to vector data (floats) */
-OSQPFloat* OSQPVectorf_data(const OSQPVectorf* a);
+OSQP_API OSQPFloat* OSQPVectorf_data(const OSQPVectorf* a);
 
 /* Copy a float vector a into another vector b (pre-allocated) */
-void OSQPVectorf_copy(OSQPVectorf*       b,
+OSQP_API void OSQPVectorf_copy(OSQPVectorf*       b,
                       const OSQPVectorf* a);
 
 /* Copy an array of floats into a into a vector b (pre-allocated) */
-void OSQPVectorf_from_raw(OSQPVectorf*     b,
+OSQP_API void OSQPVectorf_from_raw(OSQPVectorf*     b,
                           const OSQPFloat* a);
 
 /* copy an array of ints into a into a vector b (pre-allocated) */
-void OSQPVectori_from_raw(OSQPVectori*   b,
+OSQP_API void OSQPVectori_from_raw(OSQPVectori*   b,
                           const OSQPInt* a);
 
 /* copy a vector into an array of floats (pre-allocated) */
-void OSQPVectorf_to_raw(OSQPFloat*         bv,
+OSQP_API void OSQPVectorf_to_raw(OSQPFloat*         bv,
                         const OSQPVectorf* a);
 
 /* copy a vector into an array of ints (pre-allocated) */
-void OSQPVectori_to_raw(OSQPInt*           bv,
+OSQP_API void OSQPVectori_to_raw(OSQPInt*           bv,
                         const OSQPVectori* a);
 
 /* set float vector to scalar */
-void OSQPVectorf_set_scalar(OSQPVectorf* a,
+OSQP_API void OSQPVectorf_set_scalar(OSQPVectorf* a,
                             OSQPFloat    sc);
 
 /* Set float vector to one of three scalars based on sign of vector of ints */
-void OSQPVectorf_set_scalar_conditional(OSQPVectorf*       a,
+OSQP_API void OSQPVectorf_set_scalar_conditional(OSQPVectorf*       a,
                                         const OSQPVectori* test,
                                         OSQPFloat          val_if_neg,
                                         OSQPFloat          val_if_zero,
@@ -136,32 +136,32 @@ void OSQPVectorf_set_scalar_conditional(OSQPVectorf*       a,
 /**
  * Round any values of a between [-tol, tol] to zero, creating a deadband around 0.
  */
-void OSQPVectorf_round_to_zero(OSQPVectorf* a,
+OSQP_API void OSQPVectorf_round_to_zero(OSQPVectorf* a,
                                OSQPFloat    tol);
 
 /* multiply float vector by float */
-void OSQPVectorf_mult_scalar(OSQPVectorf* a,
+OSQP_API void OSQPVectorf_mult_scalar(OSQPVectorf* a,
                              OSQPFloat    sc);
 
 /* x = a + b.  Set x == a for x += b. */
-void OSQPVectorf_plus(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_plus(OSQPVectorf*       x,
                       const OSQPVectorf* a,
                       const OSQPVectorf* b);
 
 /* x = a - b.  Set x==a for x -= b. */
-void OSQPVectorf_minus(OSQPVectorf*      x,
+OSQP_API void OSQPVectorf_minus(OSQPVectorf*      x,
                       const OSQPVectorf* a,
                       const OSQPVectorf* b);
 
 /* x = sca*a + scb*b.  Set (x == a, sca==1.) for x += scb*b. */
-void OSQPVectorf_add_scaled(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_add_scaled(OSQPVectorf*       x,
                             OSQPFloat          sca,
                             const OSQPVectorf* a,
                             OSQPFloat          scb,
                             const OSQPVectorf* b);
 
 /* x = sca*a + scb*b + scc*c.  Set (x == a, sca==1.) for x += scb*b scc*c. */
-void OSQPVectorf_add_scaled3(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_add_scaled3(OSQPVectorf*       x,
                              OSQPFloat          sca,
                              const OSQPVectorf* a,
                              OSQPFloat          scb,
@@ -170,24 +170,24 @@ void OSQPVectorf_add_scaled3(OSQPVectorf*       x,
                              const OSQPVectorf* c);
 
 /* ||v||_inf */
-OSQPFloat OSQPVectorf_norm_inf(const OSQPVectorf* v);
+OSQP_API OSQPFloat OSQPVectorf_norm_inf(const OSQPVectorf* v);
 
 /* ||Sv||_inf */
-OSQPFloat OSQPVectorf_scaled_norm_inf(const OSQPVectorf* S,
+OSQP_API OSQPFloat OSQPVectorf_scaled_norm_inf(const OSQPVectorf* S,
                                       const OSQPVectorf* v);
 
 /* ||a - b||_inf */
-OSQPFloat OSQPVectorf_norm_inf_diff(const OSQPVectorf* a,
+OSQP_API OSQPFloat OSQPVectorf_norm_inf_diff(const OSQPVectorf* a,
                                     const OSQPVectorf* b);
 
 /* ||v||2 */
-OSQPFloat OSQPVectorf_norm_2(const OSQPVectorf* v);
+OSQP_API OSQPFloat OSQPVectorf_norm_2(const OSQPVectorf* v);
 
 /* ||v||1 */
-OSQPFloat OSQPVectorf_norm_1(const OSQPVectorf* a);
+OSQP_API OSQPFloat OSQPVectorf_norm_1(const OSQPVectorf* a);
 
 /* Inner product a'b */
-OSQPFloat OSQPVectorf_dot_prod(const OSQPVectorf* a,
+OSQP_API OSQPFloat OSQPVectorf_dot_prod(const OSQPVectorf* a,
                                const OSQPVectorf* b);
 
 /* Inner product a'b, but using only the positive or negative
@@ -195,26 +195,26 @@ OSQPFloat OSQPVectorf_dot_prod(const OSQPVectorf* a,
  * negative terms.  Setting any other value for sign will return
  * the normal dot product
  */
-OSQPFloat OSQPVectorf_dot_prod_signed(const OSQPVectorf* a,
+ OSQP_API OSQPFloat OSQPVectorf_dot_prod_signed(const OSQPVectorf* a,
                                       const OSQPVectorf* b,
                                       OSQPInt            sign);
 
 /* Elementwise product a.*b stored in c.  Set c==a for c *= b */
-void OSQPVectorf_ew_prod(OSQPVectorf*       c,
+OSQP_API void OSQPVectorf_ew_prod(OSQPVectorf*       c,
                          const OSQPVectorf* a,
                          const OSQPVectorf* b);
 
 /* check l <= u elementwise.  Returns 1 if inequality is true
  * for every element pair in both vectors
  */
-OSQPInt OSQPVectorf_all_leq(const OSQPVectorf* l,
+OSQP_API OSQPInt OSQPVectorf_all_leq(const OSQPVectorf* l,
                             const OSQPVectorf* u);
 
 /* Elementwise bounding vectors x = min(max(z,l),u)
  * It is acceptable to assign x = z in this call, so
  * that x = min(max(x,l),u) is allowed
  */
-void OSQPVectorf_ew_bound_vec(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_ew_bound_vec(OSQPVectorf*       x,
                               const OSQPVectorf* z,
                               const OSQPVectorf* l,
                               const OSQPVectorf* u);
@@ -224,7 +224,7 @@ void OSQPVectorf_ew_bound_vec(OSQPVectorf*       x,
    of the set [l u].  Values of +/- infval or larger are
    treated as infinite
  */
-void OSQPVectorf_project_polar_reccone(OSQPVectorf*       y,
+OSQP_API void OSQPVectorf_project_polar_reccone(OSQPVectorf*       y,
                                        const OSQPVectorf* l,
                                        const OSQPVectorf* u,
                                        OSQPFloat          infval);
@@ -234,7 +234,7 @@ void OSQPVectorf_project_polar_reccone(OSQPVectorf*       y,
    treated as infinite.  Values in y within tol of zero are treated
    as zero.
  */
-OSQPInt OSQPVectorf_in_reccone(const OSQPVectorf* y,
+OSQP_API OSQPInt OSQPVectorf_in_reccone(const OSQPVectorf* y,
                                const OSQPVectorf* l,
                                const OSQPVectorf* u,
                                OSQPFloat          infval,
@@ -243,19 +243,19 @@ OSQPInt OSQPVectorf_in_reccone(const OSQPVectorf* y,
 # if OSQP_EMBEDDED_MODE != 1
 
 /* Vector elementwise reciprocal b = 1./a (needed for scaling)*/
-void OSQPVectorf_ew_reciprocal(OSQPVectorf*       b,
+OSQP_API void OSQPVectorf_ew_reciprocal(OSQPVectorf*       b,
                                const OSQPVectorf* a);
 
 /* elementwise sqrt of the vector elements */
-void OSQPVectorf_ew_sqrt(OSQPVectorf* a);
+OSQP_API void OSQPVectorf_ew_sqrt(OSQPVectorf* a);
 
 /* Elementwise maximum between vectors c = max(a, b) */
-void OSQPVectorf_ew_max_vec(OSQPVectorf*       c,
+OSQP_API void OSQPVectorf_ew_max_vec(OSQPVectorf*       c,
                             const OSQPVectorf* a,
                             const OSQPVectorf* b);
 
 /* Elementwise minimum between vectors c = min(a, b) */
-void OSQPVectorf_ew_min_vec(OSQPVectorf*       c,
+OSQP_API void OSQPVectorf_ew_min_vec(OSQPVectorf*       c,
                             const OSQPVectorf* a,
                             const OSQPVectorf* b);
 
@@ -266,7 +266,7 @@ void OSQPVectorf_ew_min_vec(OSQPVectorf*       c,
 
    Returns 1 if any value in iseq has been modified.   O otherwise.
  */
-OSQPInt OSQPVectorf_ew_bounds_type(OSQPVectori*       iseq,
+OSQP_API OSQPInt OSQPVectorf_ew_bounds_type(OSQPVectori*       iseq,
                                    const OSQPVectorf* l,
                                    const OSQPVectorf* u,
                                    OSQPFloat          tol,
@@ -276,7 +276,7 @@ OSQPInt OSQPVectorf_ew_bounds_type(OSQPVectori*       iseq,
 /* Elementwise replacement based on lt comparison.
    x[i] = z[i] < testval ? newval : z[i];
 */
-void OSQPVectorf_set_scalar_if_lt(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_set_scalar_if_lt(OSQPVectorf*       x,
                                   const OSQPVectorf* z,
                                   OSQPFloat          testval,
                                   OSQPFloat          newval);
@@ -284,7 +284,7 @@ void OSQPVectorf_set_scalar_if_lt(OSQPVectorf*       x,
 /* Elementwise replacement based on gt comparison.
  * x[i] = z[i] > testval ? newval : z[i];
  */
-void OSQPVectorf_set_scalar_if_gt(OSQPVectorf*       x,
+OSQP_API void OSQPVectorf_set_scalar_if_gt(OSQPVectorf*       x,
                                   const OSQPVectorf* z,
                                   OSQPFloat          testval,
                                   OSQPFloat          newval);
diff --git a/include/private/lin_alg.h b/include/private/lin_alg.h
index 7cd2a37b..b429265c 100644
--- a/include/private/lin_alg.h
+++ b/include/private/lin_alg.h
@@ -10,22 +10,22 @@ extern "C" {
 #endif
 
 /* Return which linear system solvers are supported */
-OSQPInt osqp_algebra_linsys_supported(void);
+OSQP_API OSQPInt osqp_algebra_linsys_supported(void);
 
 /* Return the default linear system the algebra backend prefers */
 enum osqp_linsys_solver_type osqp_algebra_default_linsys(void);
 
 /* Initialize libraries that implement algebra. */
-OSQPInt osqp_algebra_init_libs(OSQPInt device);
+OSQP_API OSQPInt osqp_algebra_init_libs(OSQPInt device);
 
 /* Free libraries that implement algebra. */
-void osqp_algebra_free_libs(void);
+OSQP_API void osqp_algebra_free_libs(void);
 
 /* Get the name of the linear algebra backend */
-OSQPInt osqp_algebra_name(char* name, OSQPInt nameLen);
+OSQP_API OSQPInt osqp_algebra_name(char* name, OSQPInt nameLen);
 
 /* Get the name of the device the linear algebra backend is using */
-OSQPInt osqp_algebra_device_name(char* name, OSQPInt nameLen);
+OSQP_API OSQPInt osqp_algebra_device_name(char* name, OSQPInt nameLen);
 
 /* KKT linear system definition and solution */
 
@@ -43,7 +43,7 @@ OSQPInt osqp_algebra_device_name(char* name, OSQPInt nameLen);
  * @param   polishing        0/1 depending whether we are allocating for polishing or not
  * @return                   Exitflag for error (0 if no errors)
  */
-OSQPInt osqp_algebra_init_linsys_solver(LinSysSolver**      s,
+OSQP_API OSQPInt osqp_algebra_init_linsys_solver(LinSysSolver**      s,
                                         const OSQPMatrix*   P,
                                         const OSQPMatrix*   A,
                                         const OSQPVectorf*  rho_vec,
@@ -55,7 +55,7 @@ OSQPInt osqp_algebra_init_linsys_solver(LinSysSolver**      s,
 
 #ifdef OSQP_ALGEBRA_BUILTIN
 #ifndef OSQP_EMBEDDED_MODE
-OSQPInt adjoint_derivative_linsys_solver(LinSysSolver**      s,
+OSQP_API OSQPInt adjoint_derivative_linsys_solver(LinSysSolver**      s,
                                          const OSQPSettings* settings,
                                          const OSQPMatrix*   P,
                                          const OSQPMatrix*   G,
diff --git a/include/public/osqp_api_functions.h b/include/public/osqp_api_functions.h
index bd159f14..dfb45b42 100644
--- a/include/public/osqp_api_functions.h
+++ b/include/public/osqp_api_functions.h
@@ -37,7 +37,7 @@ extern "C" {
  * @param  p     Vector of column pointers
  * @return       Pointer to new CSC matrix, or null on error
  */
-OSQPCscMatrix* OSQPCscMatrix_new(OSQPInt    m,
+OSQP_API OSQPCscMatrix* OSQPCscMatrix_new(OSQPInt    m,
                                  OSQPInt    n,
                                  OSQPInt    nzmax,
                                  OSQPFloat* x,
@@ -55,7 +55,7 @@ OSQPCscMatrix* OSQPCscMatrix_new(OSQPInt    m,
  *
  * @param mat Matrix to free
  */
-void OSQPCscMatrix_free(OSQPCscMatrix* mat);
+OSQP_API void OSQPCscMatrix_free(OSQPCscMatrix* mat);
 
 /**
  * Allocates a new Compressed-Column-Sparse (CSC) matrix with zero entries.
@@ -68,7 +68,7 @@ void OSQPCscMatrix_free(OSQPCscMatrix* mat);
  * @param  n Number of columns
  * @return   Pointer to new CSC matrix, or null on error
  */
-OSQPCscMatrix* OSQPCscMatrix_zeros(OSQPInt m,
+OSQP_API OSQPCscMatrix* OSQPCscMatrix_zeros(OSQPInt m,
                                    OSQPInt n);
 
 /**
@@ -79,7 +79,7 @@ OSQPCscMatrix* OSQPCscMatrix_zeros(OSQPInt m,
  * @param  m Number of rows/columns
  * @return   Pointer to new CSC matrix, or null on error
  */
-OSQPCscMatrix* OSQPCscMatrix_identity(OSQPInt m);
+OSQP_API OSQPCscMatrix* OSQPCscMatrix_identity(OSQPInt m);
 
 /**
  * Allocates a new Compressed-Column-Sparse (CSC) diagonal matrix with a given value.
@@ -94,7 +94,7 @@ OSQPCscMatrix* OSQPCscMatrix_identity(OSQPInt m);
  * @param  scalar Scalar value to put on the diagonal
  * @return        Pointer to new CSC matrix, or null on error
  */
-OSQPCscMatrix* OSQPCscMatrix_diag_scalar(OSQPInt   m,
+OSQP_API OSQPCscMatrix* OSQPCscMatrix_diag_scalar(OSQPInt   m,
                                          OSQPInt   n,
                                          OSQPFloat scalar);
 
@@ -111,7 +111,7 @@ OSQPCscMatrix* OSQPCscMatrix_diag_scalar(OSQPInt   m,
  * @param  vals Values to put on the diagonal - length min(n,m)
  * @return      Pointer to new CSC matrix, or null on error
  */
-OSQPCscMatrix* OSQPCscMatrix_diag_vec(OSQPInt    m,
+OSQP_API OSQPCscMatrix* OSQPCscMatrix_diag_vec(OSQPInt    m,
                                       OSQPInt    n,
                                       OSQPFloat* vals);
 
@@ -152,7 +152,7 @@ OSQP_API void OSQPCscMatrix_set_data(OSQPCscMatrix* M,
  *
  * @return Pointer to new settings object, or null on error
  */
-OSQPSettings* OSQPSettings_new();
+OSQP_API OSQPSettings* OSQPSettings_new();
 
 /**
  * Free an OSQPSettings object.
@@ -161,7 +161,7 @@ OSQPSettings* OSQPSettings_new();
  *
  * @param settings The settings object to free
  */
-void OSQPSettings_free(OSQPSettings* settings);
+OSQP_API void OSQPSettings_free(OSQPSettings* settings);
 #endif
 
 /** @} */
@@ -179,7 +179,7 @@ void OSQPSettings_free(OSQPSettings* settings);
  *
  * @return Pointer to new codegen defines object, or null on error
  */
-OSQPCodegenDefines* OSQPCodegenDefines_new();
+OSQP_API OSQPCodegenDefines* OSQPCodegenDefines_new();
 
 /**
  * Free an OSQPCodegenDefines object.
@@ -188,7 +188,7 @@ OSQPCodegenDefines* OSQPCodegenDefines_new();
  *
  * @param defs The defines object to free
  */
-void OSQPCodegenDefines_free(OSQPCodegenDefines* defs);
+OSQP_API void OSQPCodegenDefines_free(OSQPCodegenDefines* defs);
 #endif
 
 /** @} */
@@ -303,7 +303,7 @@ OSQP_API OSQPInt osqp_solve(OSQPSolver* solver);
  * @param  solution Solution object to store result in
  * @return          Error flag
  */
-OSQPInt osqp_get_solution(OSQPSolver* solver, OSQPSolution* solution);
+OSQP_API OSQPInt osqp_get_solution(OSQPSolver* solver, OSQPSolution* solution);
 
 # ifndef OSQP_EMBEDDED_MODE
 
-- 
2.39.5 (Apple Git-154)

